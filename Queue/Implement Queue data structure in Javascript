1. Here's an implementation of a Queue data structure in JavaScript using an array:

    class Queue {
      constructor() {
        this.items = [];
      }

      enqueue(element) {
        this.items.push(element);
      }

      dequeue() {
        if (this.isEmpty()) {
          return "Underflow";
        }
        return this.items.shift();
      }

      front() {
        if (this.isEmpty()) {
          return "No elements in Queue";
        }
        return this.items[0];
      }

      isEmpty() {
        return this.items.length === 0;
      }

      printQueue() {
        let str = "";
        for (let i = 0; i < this.items.length; i++) {
          str += this.items[i] + " ";
        }
        return str;
      }
    }

The enqueue method adds an element to the end of the queue, while dequeue removes and returns the element at the front of the queue.
The front method returns the element at the front of the queue without removing it, while the isEmpty method returns true if the queue is empty and false otherwise.
The printQueue method returns a string representation of the elements in the queue.


2. Here's an implementation of a Queue data structure in JavaScript using a linked list:

    class Node {
      constructor(data) {
        this.data = data;
        this.next = null;
      }
    }

    class Queue {
      constructor() {
        this.front = null;
        this.rear = null;
        this.size = 0;
      }

      enqueue(data) {
        let newNode = new Node(data);
        if (this.rear === null) {
          this.front = newNode;
          this.rear = newNode;
        } else {
          this.rear.next = newNode;
          this.rear = newNode;
        }
        this.size++;
      }

      dequeue() {
        if (this.front === null) {
          return "Underflow";
        }
        let removedNode = this.front;
        this.front = this.front.next;
        if (this.front === null) {
          this.rear = null;
        }
        this.size--;
        return removedNode.data;
      }

      isEmpty() {
        return this.size === 0;
      }

      getFront() {
        return this.front ? this.front.data : "No elements in Queue";
      }

      printQueue() {
        let str = "";
        let temp = this.front;
        while (temp) {
          str += temp.data + " ";
          temp = temp.next;
        }
        return str;
      }
    }


In this implementation, we define a Node class to represent each element in the queue, and a Queue class that maintains a front and rear pointer to the first and last nodes in the linked list.
The enqueue method adds a new node to the end of the linked list, while the dequeue method removes and returns the node at the front of the linked list.
The isEmpty method checks if the queue is empty, and the getFront method returns the data of the first node in the linked list without removing it.
The printQueue method returns a string representation of the elements in the queue.
